#include "adc.h"

//
// External ADC Handle defined in main.c (generated by STM32Cube or manual)
//
extern ADC_HandleTypeDef hadc1;

//
// FreeRTOS Mutex to protect the shared ADC peripheral
//
SemaphoreHandle_t adc_mutex = NULL;

// ==================== ADC & Joystick Functions ====================

//
// Initializes ADC1 for Joystick Axes and GPIOB for the Button
// Sets up the FreeRTOS Mutex for thread safety
//
void ADC_Joystick_Init(void)
{
    // 1. Create the Mutex for thread-safe hardware access
    if (adc_mutex == NULL)
    {
        adc_mutex = xSemaphoreCreateMutex();
    }

    // 2. Enable Peripheral Clocks
    __HAL_RCC_ADC1_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE(); // For Analog Pins (PA0, PA1)
    __HAL_RCC_GPIOB_CLK_ENABLE(); // For Button Pin (PB3)

    // 3. Configure GPIO for Analog Inputs (PA0, PA1)
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = JOY_PIN_X | JOY_PIN_Y;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(JOY_PORT_ANALOG, &GPIO_InitStruct);

    // 4. Configure GPIO for Button Input (PB3)
    // Note: Use Pull-Up because the switch connects to GND when pressed
    GPIO_InitStruct.Pin = JOY_PIN_BUTTON;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(JOY_PORT_BUTTON, &GPIO_InitStruct);

    // 5. Configure ADC Peripheral Global Settings
    hadc1.Instance = JOY_ADC_INSTANCE;
    hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
    hadc1.Init.Resolution = ADC_RESOLUTION_VAL;
    hadc1.Init.ScanConvMode = DISABLE;             // Single channel polling
    hadc1.Init.ContinuousConvMode = DISABLE;       // Single shot mode
    hadc1.Init.DiscontinuousConvMode = DISABLE;
    hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
    hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
    hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc1.Init.NbrOfConversion = 1;
    hadc1.Init.DMAContinuousRequests = DISABLE;
    hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;

    HAL_ADC_Init(&hadc1);
}

//
// Configures the channel, starts conversion, and returns the value
// Uses Mutex locking to prevent race conditions on the ADC registers
//
uint16_t ADC_Read_Locked(uint32_t channel)
{
    ADC_ChannelConfTypeDef sConfig = {0};
    uint16_t result = 0;

    // Check Scheduler State to prevent deadlock during early initialization
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED && adc_mutex != NULL)
    {
        // Attempt to take Mutex
        if (xSemaphoreTake(adc_mutex, pdMS_TO_TICKS(ADC_TIMEOUT)) == pdTRUE)
        {
            // Configure the selected channel
            sConfig.Channel = channel;
            sConfig.Rank = 1;
            sConfig.SamplingTime = ADC_SAMPLE_TIME;
            HAL_ADC_ConfigChannel(&hadc1, &sConfig);

            // Perform Conversion
            HAL_ADC_Start(&hadc1);
            if (HAL_ADC_PollForConversion(&hadc1, ADC_TIMEOUT) == HAL_OK)
            {
                result = HAL_ADC_GetValue(&hadc1);
            }
            HAL_ADC_Stop(&hadc1);

            // Release Mutex
            xSemaphoreGive(adc_mutex);
        }
    }
    else
    {
        // Fallback for pre-scheduler usage
        sConfig.Channel = channel;
        sConfig.Rank = 1;
        sConfig.SamplingTime = ADC_SAMPLE_TIME;
        HAL_ADC_ConfigChannel(&hadc1, &sConfig);

        HAL_ADC_Start(&hadc1);
        if (HAL_ADC_PollForConversion(&hadc1, ADC_TIMEOUT) == HAL_OK)
        {
            result = HAL_ADC_GetValue(&hadc1);
        }
    }

    return result;
}

//
// Helper to read the digital button state
// Returns 0 if Pressed (Active Low), 1 if Released
//
// Example logic for active-low button (standard for most joysticks)
uint8_t ADC_ReadButton(void)
{
    // If the pin is RESET (0), it means the button is pressed
    if (HAL_GPIO_ReadPin(JOY_PORT_BUTTON, JOY_PIN_BUTTON) == GPIO_PIN_RESET)
    {
        return 1; // Return "True" for pressed
    }
    return 0; // Return "False" for released
}
